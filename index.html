<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>My Family</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    font-family: Arial, sans-serif;
    background: #f9f9f9;
    overflow: hidden;
  }
  h2 {
    text-align: center;
    margin: 10px 0;
  }
  .controls {
    text-align: center;
    margin: 5px;
  }
  .tree-container {
    width: 100%;
    height: calc(100vh - 90px);
    overflow: hidden;
    border-top: 1px solid #ccc;
    background: white;
  }
  svg {
    font: 12px sans-serif;
    user-select: none;
    cursor: grab;
  }
  .node circle {
    fill: #4a90e2;
    stroke: #357ABD;
    stroke-width: 2px;
    cursor: pointer;
    transition: fill 0.3s;
  }
  .node circle.collapsed {
    fill: #fc0313;
  }
  .node text {
    font-size: 14px;
    fill: #333;
    cursor: pointer;
    user-select: none;
  }
  .link {
    fill: none;
    stroke: #aaa;
    stroke-opacity: 0.6;
    stroke-width: 2px;
  }
</style>
</head>
<body>
  <h2>My Family</h2>
  <div class="controls">
    <button id="resetView">Reset View</button>
  </div>
  <div class="tree-container">
    <svg></svg>
  </div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
const container = d3.select(".tree-container");
const svg = d3.select("svg");

const zoom = d3.zoom()
  .scaleExtent([0.1, 3]) // min and max zoom
  .on("zoom", (event) => {
    g.attr("transform", event.transform);
  });
svg.call(zoom);

let g; // will hold the group
let rootHierarchy;

d3.csv("family_tree.csv").then(data => {
  const dataPairs = data.map(row => [
    { id: row.parent_id, name: row.parent_name },
    { id: row.child_id, name: row.child_name }
  ]);

  const nodes = new Map();

  for (const [parent, child] of dataPairs) {
    if (!nodes.has(parent.id)) {
      nodes.set(parent.id, { id: parent.id, name: parent.name, children: [] });
    }
    if (!nodes.has(child.id)) {
      nodes.set(child.id, { id: child.id, name: child.name, children: [] });
    }
    nodes.get(parent.id).children.push(nodes.get(child.id));
  }

  const childIds = new Set(dataPairs.map(([_, c]) => c.id));
  const root = [...nodes.values()].find(n => !childIds.has(n.id));

  rootHierarchy = d3.hierarchy(root);

  update(rootHierarchy);
});

function toggle(d) {
  if (d.children) {
    d._children = d.children;
    d.children = null;
  } else if (d._children) {
    d.children = d._children;
    d._children = null;
  }
  update(d);
}

function update(source) {
  const nodeHeight = 70;
  const nodeWidth = 140;
  const margin = 50;

  const treeLayout = d3.tree().nodeSize([nodeHeight, nodeWidth]);
  treeLayout(rootHierarchy);

  const nodesArray = rootHierarchy.descendants();

  const xVals = nodesArray.map(d => d.x);
  const yVals = nodesArray.map(d => d.y);
  const minX = Math.min(...xVals);
  const maxX = Math.max(...xVals);
  const minY = Math.min(...yVals);
  const maxY = Math.max(...yVals);

  const containerNode = container.node();
  const viewportWidth = containerNode.clientWidth;
  const viewportHeight = containerNode.clientHeight;

  svg
    .attr("width", viewportWidth)
    .attr("height", viewportHeight);

  svg.selectAll("*").remove();

  g = svg.append("g");

  g.selectAll(".link")
    .data(rootHierarchy.links())
    .join("path")
    .attr("class", "link